classdef seudo < handle
    
    properties
        
        % user-provided name, used to label display
        name
        
        % specification of motion-corrected dF/F movie
        movieSpec       % matrix, tif file list, or user function
        movieType       % 'mat', 'tif', or 'fcn'
        movY            % # pixels vertically
        movX            % # pixels horizontally
        movF            % # of frames
        nCells          % # cells
        zeroLevel       % value in movie that correspondes to zero dF/F
                        %   storing this value separately allows the movie data
                        %   class to be an unsigned integer, potentially saving memory
        
        % cell profiles (aka cell shapes, ROIs, sources, footprints, ...)
        %   Y x X x (# cells) matrix
        profiles
        
        % "default" time courses, i.e. not using SEUDO
        %   struct with fields:
        %       tc - (# frames) x (# cells) matrix
        %       transientInfo - see below
        %
        %   used only for providing comparison to seudo time courses
        %   if not provided, LSQ time courses are computed
        %
        tcDefault
        
        % time courses with artificially high contamintation
        %   struct with fields:
        %       tc - (# frames) x (# cells) matrix
        %       transientInfo - see below
        %
        %   generated by computeLSQtimeCoursesHighContam
        %
        tcContam
        
        % results from running SEUDO
        %   struct array with fields:
        %       tc - time courses, (# frames) x (# cells) matrix
        %       transientInfo - see below
        %       params - struct of parameters
        %
        %   each time estimateTimeCoursesSEUDO is called, a new entry is added to the struct array
        %
        tcSeudo        
        
        %   transientInfo
        %
        %       struct array of information about each cell's transients
        %       for list of all fields, see documentation for computeTransientInfo
        %
        %
        %
        
    end
    
    methods
        se = runSEUDOonTransientProfiles(se,varargin)
        se = estimateTimeCoursesWithSEUDO(se,varargin)
        se = estimateTransientsOnlyWithSEUDO(se,varargin)
        se = parallelSEUDO(se, varargin)
        % methods in separate files:
        %
        %   classifyTransients
        %       launch GUI to classify tcDefault or tcContam
        %   showSummaryStats
        %       for manually classified transients, show how SEUDO performed
        %   compareDefaultTCtoSEUDO
        %       display full time courses, comparing SEUDO to LSQ
        %   ...
        %       
        
        % constructor
        function se = seudo(movieSpec,profiles,varargin)
            
            p = inputParser;
            p.addParameter('name'        ,'untitled movie');               % name of dataset
            p.addParameter('timeCourses' ,[]);                             % time courses from user analysis
            p.addParameter('nFrames'     ,[]);                             % # movie frames, only needed if movie spec is function handle
            p.addParameter('zeroLevel'   ,0);                              % value that corresponds to 0 dF/F
            
            % load a struct of time courses and transient classification from a file
            p.addParameter('tcDefault' ,'');                               % default time courses
            p.addParameter('tcContam'  ,'');                               % high contamination time courses
            p.addParameter('tcSeudo'   ,'');                               % seudo time courses           
            p.addParameter('verbose'   ,true);                             % don't show any output
            p.addParameter('computeTransientInfo',true);                   % Decide if we need to 
            parse(p,varargin{:});
         
            if p.Results.verbose, fprintf('Loading SEUDO object data\n'), end
            
            % VALIDATE AND STORE MOVIE SPECIFICATION
            
            if isempty(movieSpec)                                          % IF: not specified
                
                % fill in profile size
                se.movY = size(profiles,1);
                se.movX = size(profiles,2);
                
                se.movF = p.Results.nFrames;                               % use frame count, if specified
                if isempty(se.movF), se.movF = nan; end                    % set to nan if not specified
                
                % store in object
                se.movieSpec = [];
                se.movieType = 'empty';
                
            elseif isnumeric(movieSpec)                                    % IF: matrix, Y x X x F
                
                % ensure it's a 3d matrix
                assert(length(size(movieSpec)) == 3)
                
                % note size
                [se.movY, se.movX, se.movF] = size(movieSpec);
                
                % store in object
                se.movieSpec = movieSpec;
                se.movieType = 'mat';
                
            elseif iscellstr(movieSpec) %#ok<ISCLSTR>
                % cell array of image files
                
                % ensure all files exist
                for ff = 1:length(movieSpec)
                    if ~exist(movieSpec{ff},'file')
                        error('could not find file %s',movieSpec{ff})
                    end
                end
                
                % get # images in each file and ensure all are the same size
                imInfos = cell(length(movieSpec),1);
                imCounts = zeros(length(movieSpec),1);
                for ff = 1:length(movieSpec)
                    % get movie info
                    thisInfo = imfinfo(movieSpec{ff});
                    % first time, note size
                    if ff == 1
                        se.movY = thisInfo(1).Height;
                        se.movX = thisInfo(1).Width;
                    else
                        % subsequently, ensure the same size
                        assert(se.movY == thisInfo(1).Height)
                        assert(se.movX == thisInfo(1).Width)
                    end
                    % note info
                    imInfos{ff}  = thisInfo;
                    imCounts(ff) = length(thisInfo);
                end
                
                % store data in object
                se.movieSpec = {movieSpec,imInfos,imCounts};
                se.movieType = 'tif';
                se.movF      = sum(imCounts);
                
            elseif isequal(class(movieSpec),'function_handle')
                % function handle
                % must take a single argument (frame number) and output a matrix (movie frame)
                se.movieSpec = movieSpec;
                se.movieType = 'fcn';
                
                % note frame size
                testFrame = movieSpec(1);
                [se.movY, se.movX] = size(testFrame);
                
                % note # frames
                se.movF = p.Results.nFrames;
                if isempty(se.movF)
                    error('when movie spec is fcn handle, number of frames must be provided in argument ''nFrames''')
                end
            else
                error('movie specification not recognized')
            end
            
            
            se.zeroLevel = p.Results.zeroLevel;
            
            if p.Results.verbose, fprintf('     Movie: %d by %d pixels, %d frames\n',se.movY,se.movX,se.movF), end
            
            % VALIDATE AND STORE PROFILES
            
            % ensure profile size matches movie size
            if ~isequal(size(profiles(:,:,1)),[se.movY se.movX])
                error('size of profiles (%d x %d) does not match size size of movie (%d x %d)',...
                    size(profiles(:,:,1)),[se.movY se.movX])
            end
            
            % store profiles in object
            se.profiles = profiles;
            se.nCells   = size(se.profiles,3);

            if p.Results.verbose, fprintf('     Profiles: %d cells\n',size(se.profiles,3)), end
            
            % LOAD ANY SAVED TIME COURSE STRUCTS
            
            if ~isempty(p.Results.tcDefault)
                if ischar(p.Results.tcDefault)
                    se.tcDefault = load(p.Results.tcDefault);
                else
                    se.tcDefault = p.Results.tcDefault;
                end
                validateTCstruct(se,se.tcDefault)
            end
            
            if ~isempty(p.Results.tcContam)
                if ischar(p.Results.tcContam)
                    se.tcContam = load(p.Results.tcContam);
                else
                    se.tcContam = p.Results.tcContam;
                end
                validateTCstruct(se,se.tcContam)
            end
            
            if ~isempty(p.Results.tcSeudo)
                if ischar(p.Results.tcSeudo)
                    se.tcSeudo = load(p.Results.tcSeudo);
                else
                    se.tcSeudo = p.Results.tcSeudo;
                end
                validateTCstruct(se,se.tcSeudo)
            end
            
            % STORE "DEFAULT" TIME COURSES
            
            % if a time course struct for default time courses was not provided above...
            if isempty(se.tcDefault)
                
                if ~isempty(p.Results.timeCourses)
                    % if specified by user, store those
                    se.tcDefault.tc = p.Results.timeCourses;
                    % ensure sizes match
                    validateTCstruct(se,se.tcDefault)
                    fprintf('Default time courses: provided by user\n')
                    
                else
                    % if not provided by user, compute least squares time courses
                    
                    if isnan(se.movF)
                        error(sprintf(['when creating a seudo object without specifying the movie, either the number of frames or a time course struct must be provided, e.g.\n'...
                            '   seudo([],profileMatrix,''nFrames'')\nor\n   seudo([],profileMatrix,''tcDefault'',''/path/file.mat'')\n']))
                    end
                    
                    se.computeLSQtimeCourses(p.Results.verbose)
                end
            else
                % if a default time course was provided, ensure it's consistent with loaded file
                if ~isempty(p.Results.timeCourses)
                    if ~isequaln(p.Results.timeCourses,se.tcDefault.tc)
                        
                        % in this case, the loaded tcStruct and the provided time courses do not agree
                        if isequal(size(p.Results.timeCourses),size(se.tcDefault.tc))
                            % if sizes are equal, just warn
                            warning('Provided time courses are not identical to time course struct loaded from file:\n   %s)',p.Results.tcDefault)
                        else
                            % if sizes are not equal, throw error
                            if ischar(p.Results.tcDefault), loadSource = p.Results.tcDefault; else; loadSource = 'provided struct'; end
                            error('Sizes do not match for provided time courses (%d frames,%d cells) and specified time course struct (%d frames, %d cells, loaded from %s).',...
                                size(p.Results.timeCourses),size(se.tcDefault.tc),loadSource)
                        end
                        %warning('time courses were provided, but were not loaded since a default time course struct was also provided')
                    end
                end
            end
            
            
            % add name
            se.name = p.Results.name;
            
            % compute default transient info
            if isempty(p.Results.tcDefault)
                if p.Results.computeTransientInfo
                    startTime = now;
                    if p.Results.verbose, fprintf('computing transient info...'), end
                    se.computeTransientInfo('default')
                    if p.Results.verbose, fprintf('done in %0.1f min\n',(now-startTime)*24*60), end
                end
            end
            
            % show suggested parameters
            %if p.Results.verbose, se.suggestParameters, end
            
            % notice if no tfocs
            if ~exist('tfocs','file')
                fprintf('\nTFOCS NOT FOUND. IT MUST BE INSTALLED FOR FULL FUNCTIONALITY.\n   download from http://cvxr.com/tfocs/download/\n\n')
            end
        end
       
        
        % load frame
        function theFrame = getFrame(se,whichFrame,subsetY, subsetX)
                        
            % default to all pixels
            if nargin < 4, subsetX = []; end
            if nargin < 3, subsetY = []; end
             
            switch se.movieType
                case 'mat'
                    % get desired frame
                    theFrame = se.movieSpec(:,:,whichFrame);
                    
                case 'tif'
                    % identify which file has the image, and which frame in that file
                    cumIms = cumsum(se.movieSpec{3});
                    whichFile = find(whichFrame<=cumIms,1,'first');
                    frameInFile = whichFrame - sum(se.movieSpec{3}(1:whichFile-1));
                    
                    % load the desired frame from the proper file
                    theFrame = imread(se.movieSpec{1}{whichFile},frameInFile,'info',se.movieSpec{2}{whichFile});
                    
                case 'fcn'
                    % call user function
                    theFrame = se.movieSpec(whichFrame);
                    
                case 'empty'
                    error('Movie data not available. To use functions that require movie data, specify movie when loading seudo object.')
            end
            
            % pare to desired subset
            if ~isempty(subsetY), theFrame = theFrame(subsetY,:); end
            if ~isempty(subsetX), theFrame = theFrame(:,subsetX); end

            
            % subtract zero level
            theFrame = double(theFrame) - se.zeroLevel;
        end
        
        
        
        % load frame
        function mov = getFrames(se,whichFrames,varargin)
            % load subset of the movie
            % usage: mov = getFrames(se,whichFrames);
            %        mov = getFrames(se,whichFrames,subsetY,subsetX);
            
            % get one frame to learn size
            testFrame = se.getFrame(whichFrames(1),varargin{:});
            
            % load all specified frames
            mov = nan(size(testFrame,1),size(testFrame,2),length(whichFrames));
            for ff = 1:length(whichFrames)
                mov(:,:,ff) = se.getFrame(whichFrames(ff),varargin{:});
            end
            
        end
        
        
        
        % compute LSQ time courses
        function computeLSQtimeCourses(se,verbose)
            % compute a simple least-squares fit to identify cell time courses
            %
            % note: if a cell's profile is all zeros, its time course will be all NaNs
            %
            
            if ~exist('verbose','var'), verbose = true; end
            
            if verbose,fprintf('Computing time courses via least-squares...\n'),end
            
            % intialize variable
            se.tcDefault.tc = nan(se.movF,size(se.profiles,3));
            
            % get reshaped profiles
            P = reshape(se.profiles,[],size(se.profiles,3));
            
            % identify and remove profiles that are all zero
            allZeroProfiles = all(P==0,1);
            P = P(:,~allZeroProfiles);
            
            % identify pixels that are zero in all profiles
            allZeroPix = all(P==0,2);
            
            % pick on which frames to show update
            initialFrames = [1 3 10 30 100 300 1000];
            initialFrames = initialFrames(initialFrames<se.movF*.2);
            prcFrames     = round(linspace(0,se.movF,21));
            prcFrames     = prcFrames(prcFrames>initialFrames(end));
            updateFrames  = [initialFrames prcFrames];
            
            if ~verbose, updateFrames = []; end
            
            startTime = now;
            for ff = 1:se.movF
                
                % get reshaped frame
                F = reshape(se.getFrame(ff),[],1);
                
                % compute LSQ fit
                se.tcDefault.tc(ff,~allZeroProfiles) = (P(~allZeroPix,:)\F(~allZeroPix))';
                
                
                if ismember(ff,updateFrames)
                    finishDur = (se.movF-ff)/ff*(now-startTime);
                    fprintf('      completed %d of %d (%0.1f%%) in %0.1f min, estimated finish in %0.1f min (%s)\n',...
                        ff, se.movF, 100*ff/se.movF,(now-startTime)*24*60,finishDur*24*60,datestr(now+finishDur))
                    %whos
                end
                
                
            end
            
            if verbose,fprintf('done in %0.1f min\n',24*60*(now-startTime)),end
            
        end
        
        
        
        % compute LSQ time courses
        function computeLSQtimeCourses_slow(se)
            % compute a simple least-squares fit to identify cell time courses
            %
            % note: if a cell's profile is all zeros, its time course will be all NaNs
            %
            
            fprintf('Computing time courses via least-squares...')
            startTime = now;
            
            % intialize variable
            se.tcDefault.tc = nan(se.movF,size(se.profiles,3));
            
            % get reshaped profiles
            P = reshape(se.profiles,[],size(se.profiles,3));
            
            % identify and remove profiles that are all zero
            allZeroProfiles = all(P==0,1);
            P = P(:,~allZeroProfiles);
            
            for ff = 1:se.movF
                
                % get reshaped frame
                F = reshape(se.getFrame(ff),[],1);
                
                % compute LSQ fit
                se.tcDefault.tc(ff,~allZeroProfiles) = (P\F)';
                
                if mod(ff,1000) == 1
                    disp(ff)
                end
                
            end
            
            fprintf('done in %0.1f min\n',24*60*(now-startTime))
            
        end
        
        
        
        % compute contaminated LSQ time courses
        function computeLSQtimeCoursesHighContam(se)
            % create time courses with artificially high contamination
            %    by leaving out all other found cells
            %
            % the large set of contaminating transients can be used to 
            %    evaluate how well SEUDO removes false transients while
            %    preserving true transients
            %
            %
            % note: if a cell's profile is all zeros, its time course will be all NaNs
            %
            
            fprintf('Computing contaminated least-squares time courses...')
            startTime = now;
            
            % intialize variable
            se.tcContam.tc = nan(se.movF,size(se.profiles,3));
            
            % exclude profiles that are all zero
            profilesToAnalyze = find(~all(reshape(se.profiles,[],size(se.profiles,3))==0,1));
            
            for ff = 1:se.movF
                
                % get reshaped frame
                F = reshape(se.getFrame(ff),[],1);
                
                for cc = profilesToAnalyze
                    
                    % get reshaped profile
                    P = reshape(se.profiles(:,:,cc),[],1);
                    
                    % pare to non-zero region
                    p=P(P~=0);f=F(P~=0);
                    
                    % compute LSQ fit
                    se.tcContam.tc(ff,cc) = (p\f)';
                end
            end
            
            fprintf('done in %0.1f min\n',24*60*(now-startTime))
        end
        
        
        
        % launch classification GUI
        function classifyTransients(se,userStructChoice)
            
            if ~exist('userStructChoice','var')
                userStructChoice = 'default';
            end
            
            structSpec = pickTcStruct(se,userStructChoice);
            
                        
            % ensure active shapes are computed
            if ~isfield(se.(structSpec{1})(structSpec{2}),'transientInfo') || isempty(se.(structSpec{1})(structSpec{2}).transientInfo)
                startTime = now;
                fprintf('computing transient info...')
                se.computeTransientInfo(userStructChoice);
                fprintf('done in %0.1f min\n',(now-startTime)*24*60)
            end
            
            seudoClassifyTransients(se,structSpec)
            
        end
        
        
        
        % validate struct 
        function validateTCstruct(se,tcStruct)
            
            assert(isstruct(tcStruct))
            
            assert(isfield(tcStruct,'tc'))
            
            % get # frames from time courses (if needed)
            if isnan(se.movF), se.movF = size(tcStruct.tc,1); end
            
            % time course size
            if size(tcStruct.tc,1) ~= se.movF
                error('# of movie frames (%d) does not match length of time courses (%d)',se.movF,size(tcStruct.tc,1))
            end
            
            % cell count
            if size(tcStruct.tc,2) ~= size(se.profiles,3)
                error('# of profiles (%d) does not match number of time courses (%d)',size(se.profiles,3),size(tcStruct.tc,2))
            end
            
            if isfield(tcStruct,'transientInfo') && ~isempty(tcStruct.transientInfo)
                % cell count
                assert(length(tcStruct.transientInfo) == size(se.profiles,3))
            end
        end
        
        
        
        % estimate parameters
        function varargout = suggestParameters(se)
            % seudoObject.suggestParameters
            %
            % use statistics of found cells to suggest some parameter values
            %
            
            fprintf('\nsuggested parameters for %s:\n\n',se.name)
            
            
            if 1
                isTrans = false(se.movF,size(se.profiles,3));
                
                % for each cell...
                for cc=1:size(se.profiles,3)
                    
                    % identify which points occur during transients
                    tTimes = se.tcDefault.transientInfo(cc).times;
                    for tt=1:size(tTimes,1)
                        isTrans(tTimes(tt,1):tTimes(tt,2),cc) = true;
                    end
                    
                end
                
                % estimate noise level (sigma) and activity level (lambda)
                sigmaEst = seudo.robustSTD(se.tcDefault.tc(~isTrans));
%                 actEst   = nanmean(se.tcDefault.tc(isTrans));
                actEst   = nanmax(se.tcDefault.tc(isTrans));
                if nargout == 0
                    fprintf('         time-trace sigma   %0.4f^2\n     lambdaBlob   %0.4f\n',sigmaEst,actEst)
                end
                suggestedPars.lambdaBlob = actEst;
            end
            
            
            % estimate sigma2
            %   get 10,000 pixels from the movie, take robust STD
            
            pixPerFrame = se.movX * se.movY;
            vals        = se.getFrames(1:ceil(1e5/pixPerFrame));
            sigma2Est   = seudo.robustSTD(vals(:)).^2;
            clear vals
            
            suggestedPars.sigma2 = sigma2Est;
            if nargout == 0; 
                fprintf('          sigma2   %0.4f\n',sigma2Est)
            end
            
            
            % estimate blob size
            %   see function fit_blob_std
            
            if 0||0
                mulFact = 2;
                framesNeeded = mulFact*size(se.profiles,3);
                
                if framesNeeded > se.movF
                    sigma_est = nan;
                else
                    mov = se.getFrames(1:framesNeeded);
                    
                    prof = reshape(se.profiles,size(se.profiles,1),[]);
                    mov = reshape(mov,size(mov,1),[],mulFact);
                    
                    sigma_est  = seudo.fit_blob_std(prof,mov);
                end
                
                if nargout == 0
                    fprintf('      blob size   %0.4f\n\n',sigma_est)
                end
                suggestedPars.blobSize = sigma_est;
            end
            
            
            % estimate lambdaBlob
            %   
            if nargout > 0
                varargout{1} = suggestedPars;
            end
            
            
        end
        
        
        % estimate parameters
        function suggestParametersPerCell(se,whichCells)
            fprintf('not yet implemented\n')
            return
            
            % seudoObject.suggestParametersPerCell(whichCells)
            %
            %   estimate paramters for single cells
            %
            % example: seudoObject.suggestParametersPerCell      - all cells
            %          seudoObject.suggestParametersPerCell(2:5) - specified cells
            %
            %
            
            if ~exist('whichCells','var'), whichCells =1:size(se.profiles,3); end
            
            % for debugging
            %allProfs = {};
            %allMovs = {};
            fprintf('\nsuggested parameters:\n')
            
            for cc=whichCells
                
                % identify subset in space, time
                ti = se.tcDefault.transientInfo(cc);
                win = ti.window;
                %wf = [];
                isTrans = false(se.movF,1);
                for tt = 1:size(ti.times,1)
                    %wf = [wf ti.times(tt,1):ti.times(tt,2)];
                    isTrans(ti.times(tt,1):ti.times(tt,2)) = true;
                end
                
                % load profile and movie from relevant spatial region, only during transients
                prof = se.profiles(win(1):win(2),win(3):win(4),cc);
                mov = se.getFrames(find(isTrans),win(1):win(2),win(3):win(4)); %#ok<FNDSB>
                
                % estimate blob size
                radius_est  = seudo.fit_blob_std(prof,mov);
                
                
                sigmaEst = seudo.robustSTD(se.tcDefault.tc(~isTrans));
                actEst = nanmean(se.tcDefault.tc(isTrans));
                if actEst < 0, actEst = nan; end
                
                fprintf('cell %d: sigma2 %0.3f, lambdaBlob %0.3f, blobRadius %0.3f\n',cc,sigmaEst,actEst,radius_est)
                
                % for debugging
                %allProfs{cc} = prof;
                %allMovs{cc} = mov;
            end
            
            % for debugging
            %assignin('base','allProfs',allProfs)
            %assignin('base','allMovs',allMovs)
        end
        
        
        % generate mini seudo objects
        function minis = makeMiniSeudos(se,transSpec,varargin)
            % for each selected transient, make a miniature seudo object that
            % includes only the time and space around the cell/transient
            %
            %
            % seudoObject.makeMiniSeudos(transSpec)
            %
            %   transSpec - T x 2 matrix specifying a set of transients
            %               each row is [ < cell number >  < transient number > ]
            %
        
            % include all pixels within specified radius of COM
            % include all pixels with in specified radius of non-zero pixels
            % in each mini seudo object, profiles are re-orded to make the cell of interest first
             
            p = inputParser;
            p.addParameter('padTime'  ,5); 
            p.addParameter('padSpace' ,10); 
            p.addParameter('useCOM'   ,false);
            p.addParameter('allCells' ,false); % whether to include profiles of all cells, or just the one that's relevant
            parse(p,varargin{:});
            
            
            % how many data points to include around the cell (in space) and transient (in time)
            padSpace = p.Results.padSpace;
            padTime = p.Results.padTime;
            
            
            % initialize
            minis = cell(size(transSpec,1),1);
            
            for ss=1:size(transSpec,1)
                
                thisCell = transSpec(ss,1);
                thisTransient = transSpec(ss,2);
                
                
                % identify spatial window
                
                % get outer bounds of area to which to add padding
                if p.Results.useCOM % just the COM
                    theCom = seudo.computeRoiCOMs(se.profiles(:,:,thisCell));
                    ob = round(theCom([2 2 1 1]));
                else % outer bound of non-zero pixels
                    [~,ob] = seudo.computeRoiCOMs(se.profiles(:,:,thisCell));
                end
                
                % add padding
                ob = [max(1,ob(1)-padSpace) min(se.movY,ob(2)+padSpace)  max(1,ob(3)-padSpace) min(se.movX,ob(4)+padSpace)];
                
                
                % choose time span
                
                theseFrames = se.tcDefault.transientInfo(thisCell).times(thisTransient,:);
                theseFrames = max(1,theseFrames(1)-padTime):min(se.movF,theseFrames(2)+padTime);
                
                
                % make mini-movie
                
                miniMov = nan(length(ob(1):ob(2)),length(ob(3):ob(4)),length(theseFrames));
                for ff = 1:length(theseFrames)
                    theFrame = se.getFrame(theseFrames(ff));
                    miniMov(:,:,ff) = theFrame(ob(1):ob(2),ob(3):ob(4));
                end
                
                
                % decide which cells to include
                if p.Results.allCells
                    % all cells, but re-ordered so the cell of interest is first
                    whichProfiles = [thisCell setdiff(1:se.nCells,thisCell)];
                else
                    % only the cell of interest
                    whichProfiles = thisCell;
                end
                
                % package into seudo object
                minis{ss} = seudo(miniMov,se.profiles(ob(1):ob(2),ob(3):ob(4),whichProfiles),'verbose',0);
                
                % compute transient info, and force it to consider all time points as part of one transient
                minis{ss}.computeTransientInfo('default','transientFrames',true(size(minis{ss}.tcDefault.tc)),'winRadius',100)
                
            end
        end
        
        
        
        function plotTransients(se,sourceID)
            % plot time course of specified source, showing transient times
            
            % get info about this source
            tc = se.tcDefault.tc(:,sourceID);
            ti = se.tcDefault.transientInfo(sourceID);
            
            % plot time course
            figure%(10);clf
            plot([1 se.movF],[0 0],'-','color',[1 1 1]*.9)
            hold on
            plot(tc,'color',[1 1 1]*.8)
            box off
            set(gca,'tickdir','out')
            
            % add transients
            transLevelOverall = min(tc) - 0.05 * (max(tc)-min(tc));
            transLevelOffset = 0.01 * (max(tc)-min(tc));
            for tt = 1:size(ti.times,1)
                
                % set color for showing transients
                %plotCol = [0 0 0];
                cl = ti.classification(tt);
                if     isnan(cl),               plotCol = [1 1 1]*0.5;
                elseif cl == seudo.valTrue,     plotCol = seudo.pickColor('true');
                elseif cl == seudo.valFalse,    plotCol = seudo.pickColor('false');
                else,                           plotCol = seudo.pickColor('mixed');
                end
                
                % plot transient
                transLevel = transLevelOverall + mod(tt,2)*transLevelOffset;
                plot(ti.times(tt,:),[1 1]*transLevel,'-','linewidth',5,'color',plotCol)
                text(mean(ti.times(tt,:)),transLevel,sprintf('\n%d',tt),...
                    'horizontal','center','vertical','baseline','color',plotCol,'clipping','on')
                plot(ti.times(tt,1):ti.times(tt,2),tc(ti.times(tt,1):ti.times(tt,2)),'-','color',plotCol)
            end
            
            % add labels
            xlabel('frame number')
           	%title(sprintf('%d transients identified in source %d (%s)',size(ti.times,1),sourceID,se.name))
            title(sprintf('%s, source %d: %d identified  transients',se.name,sourceID,size(ti.times,1)))
            
            % set to horizontal zoom
            h = zoom;
            set(h,'motion','horizontal','enable','on')
            
        end
        
        
        % launch quick SEUDO interface
        function quickSEUDO(se,pickedCellTransients,varargin)
            % launch GUI to rapidly test a parameter combination on several transients
            %
            % seudoObject.quickSEUDO(transSpec)
            %
            %   transSpec - T x 2 matrix specifying a set of transients
            %               each row is [ < cell number >  < transient number > ]
            %
            % In the GUI, there are mini seudo objects, each of which contains just the time points of interest
            % in a small rectangle around the cell (use optional arguments to change the rectangle size), and profiles of all
            % cells are included. To change which profiles are used during the SEUDO computation, use the argument
            % 'minPixToInclude' with the other SEUDO parameters, e.g. 
            %
            %       this will include any profile that has at least 5 nonzero pixels in the rectangle of interest:
            %           'p',0.001,'dsTime',1,'minPixToInclude',5
            %
            %       this will exclude all other profiles:
            %           'p',0.001,'dsTime',1,'minPixToInclude',inf
            %
            %

            
            minis = makeMiniSeudos(se,pickedCellTransients,'allCells',true,varargin{:});
            
            
            % launch GUI
            seudoQuickTest(minis,pickedCellTransients,se.name)
            
        end
        
        
        
        % clear classification
        function clearClassification(se,userStructChoice)
            
            if nargin < 2
                error(sprintf('must identify in which time course struct classification should be deleted, e.g.\n   seudoObject.clearClassification(''default'')\n   seudoObject.clearClassification({''seudo'',3})')) %#ok<*SPERR>
            end
            
            structSpec = pickTcStruct(se,userStructChoice);
            
            if isfield(se.(structSpec{1})(structSpec{2}),'transientInfo')
                for cc = 1:length(se.(structSpec{1})(structSpec{2}).transientInfo)
                    se.(structSpec{1})(structSpec{2}).transientInfo(cc).classification = ...
                        nan(size(se.(structSpec{1})(structSpec{2}).transientInfo(cc).times,1),1);
                    se.(structSpec{1})(structSpec{2}).transientInfo(cc).isArtifact = 0;
                end
            end
        end
        
        
        % launch GUI to review results of SEUDO computation
        function reviewSEUDO(se,userStructChoiceSEUDO)
            
            if nargin < 2, userStructChoiceSEUDO = 'seudo'; end
            
            structSpecDefault = pickTcStruct(se,'default');
            structSpecSeudo = pickTcStruct(se,userStructChoiceSEUDO);
            
                        
            % ensure active shapes are computed
            if ~isfield(se.(structSpecDefault{1})(structSpecDefault{2}),'transientInfo') ||...
                    isempty(se.(structSpecDefault{1})(structSpecDefault{2}).transientInfo)
                startTime = now;
                fprintf('computing transient info...')
                se.computeTransientInfo(structSpecDefault);
                fprintf('done in %0.1f min\n',(now-startTime)*24*60)
            end
            
            seudoReviewSEUDO(se,structSpecDefault,structSpecSeudo)
            
        end
        
        
        
        function nPerSource = getTransientCountPerSource(se,userStructChoice,sourceIDs)
            
            % choose a time course struct
            if ~exist('userStructChoice','var')
                userStructChoice = 'default';
            end
            structSpec = pickTcStruct(se,userStructChoice);
            
            if ~exist('sourceIDs','var')
                sourceIDs = 1:se.nCells;
            end
            
            % get number of transients
            nPerSource = cellfun(@(x)size(x,1),{se.(structSpec{1})(structSpec{2}).transientInfo(sourceIDs).times});
        end
        
        function plotAllTransientProfiles(se,sourceIDs,varargin)
            % 
            
            
            p = inputParser;
            p.addParameter('whichFig'  ,100);
            p.addParameter('tcSpec'  ,'default');
            p.addParameter('blur'  ,0);
            p.addParameter('nX'  ,10);
            parse(p,varargin{:});
            params = p.Results;
            
            % identify # plots needed per source (transient count, plus 1 for the profile)
            plotsPerSource = se.getTransientCountPerSource(params.tcSpec,sourceIDs) + 1;
            
            % set  plot areas
            nYs = ceil(plotsPerSource/params.nX);
            vertFracs = nYs / sum(nYs);
            vertStarts = 1 - cumsum(vertFracs);
            
            % set up figure
            figure(params.whichFig)
            clf(params.whichFig)
            
            % set up blur levels
            if length(params.blur) == 1
                params.blur = repmat(params.blur,length(sourceIDs),1);
            end
            
            % plot each source
            for ss = 1:length(sourceIDs)
                plotAllTransientProfilesOneSource(se,sourceIDs(ss),...
                    'blur',params.blur(ss),'nX',params.nX,'tcSpec',params.tcSpec,...
                    'plotSpec',{params.whichFig,[.1 vertStarts(ss) .9 vertFracs(ss)]})
                drawnow
            end
            
        end
        
        
        % plot all transients for a given cell
        function plotAllTransientProfilesOneSource(se,sourceID,varargin)
            
            
            p = inputParser;
            p.addParameter('plotSpec'  ,100);
            p.addParameter('tcSpec'  ,'default');
            p.addParameter('blur'  ,0);
            p.addParameter('nX'  ,[]);
            p.addParameter('nY'  ,[]);
            parse(p,varargin{:});
            params = p.Results;
            
            
            % create plot region
            if isnumeric(params.plotSpec)
                plotFig = params.plotSpec;
                plotArea = [0 0 1 1];
                figure(plotFig)
                clf(plotFig)
            elseif iscell(params.plotSpec)
                plotFig = params.plotSpec{1};
                plotArea = params.plotSpec{2};
                figure(plotFig)
            end
            
            
            
            
            
            % set up blurring
            if params.blur > 0
                convKernel = fspecial('gauss',ceil(params.blur*3)*[1 1],params.blur);
            else
                convKernel = [];
            end
            
            % get source profile
            structSpec = pickTcStruct(se,params.tcSpec);
            roi = se.profiles(:,:,sourceID);
            TI = se.(structSpec{1})(structSpec{2}).transientInfo(sourceID);
            win = TI.window;
            roi = roi(win(1):win(2),win(3):win(4));
            
            
            % choose plotting order
            switch 2
                case 1 % by transient peak height
                    [~,po] = sort(transPeaks,'descend');
                case 2 % by classification
                    [~,po] = sortrows([TI.classification TI.corrWithProfile]);
            end
            
            % assemble roi and shapes
            if ~isempty(po)
                M = cat(3,roi,TI.shapes(:,:,po));
            else
                M = roi;
            end
            
            % apply blurring, if desired
            if ~isempty(convKernel)
                M(:,:,2:end) = convn(M(:,:,2:end),convKernel,'same');
            end
            
            %  normalize brightness
            M = bsxfun(@rdivide,M,max(max(M)));
            
            
            
            % set up plots for transients
            % default to square-ish, but use any specified parameters
            nPlots = size(M,3) - 1;
            if isempty(params.nY) && isempty(params.nX)
                nX = ceil(sqrt(nPlots));
                nY = ceil(nPlots/nX);
            elseif isempty(params.nY) && ~isempty(params.nX)
                nX = params.nX;
                nY = ceil(nPlots/nX);
            elseif isempty(params.nX) && ~isempty(params.nY)
                nY = params.nY;
                nX = ceil(nPlots/nY);
            elseif ~isempty(params.nY) && ~isempty(params.nX)
                nY = params.nY;
                nX = params.nX;
            end
            
            % add an extra left column for the profile
            nX = nX+1;
            
            
            [~,hAll] = makeSubplots(gcf,nX,nY,.1,.1,plotArea);
            hTrans = hAll(:,2:end);
            hProf = hAll(1,1);
            hAll = [hProf; hTrans(:); hAll(2:end,1)];
            
            % get contour level
            % C = contour(roi>0,'LevelList',1); cla
            [Itmp,Jtmp] = find(roi>0,1,'first');
            C = bwtraceboundary(roi>0,[Itmp,Jtmp],'e');
            [pY,pX] = size(roi);
            C = C';
            
            % plot each image
            for pp = 1:size(M,3)
                h = hAll(pp);
                
                % show this profile
                imagesc(M(:,:,pp),'parent',h)
                axis(h,'off')
                axis(h,'image')
                
                % add contour
                hold(h,'on')
                plot(h,C(2,1:end),C(1,1:end),'-','linewidth',1,'color','c');%[0 .8 .8])
                
                % add classification
                if pp > 1
                    cl = TI.classification(po(pp-1));
                    if     isnan(cl),               plotCol = [1 1 1]*0.8;
                    elseif cl == seudo.valTrue,     plotCol = [.4 .8 1];
                    elseif cl == seudo.valFalse,    plotCol = seudo.pickColor('false');
                    elseif cl == seudo.valMix,      plotCol = seudo.pickColor('mixed');
                    elseif cl == seudo.valUnc,      plotCol = [1 1 1]*0.8;
                    else                            plotCol = [1 1 1]*0.8;
                    end
                    plot(h,.9*pX,.9*pY,'.','color',plotCol,'markersize',40)
                end
            end
                
            % add source ID
            switch 2
                case 1 % in title
                    title(hAll(1),sprintf('source %d',sourceID))
                case 2 % in y-axis
                    ylabel(hAll(1),sprintf('src %d',sourceID))
                    axis(hAll(1),'on')
                    set(hAll(1),'xtick',[],'ytick',[])
            end
            
            % remove remaining plots
            for pp = pp+1:length(hAll), axis(hAll(pp),'off'); end
            
            
        end
        
        
        
        
    end
    
    
    
    
    
    
    
    
    
    
    methods(Static)
        
        % get classification name
        function theClass = getClassName(theName)
            if isnan(theName)
                theClass = 'unclassified';
            elseif theName == -1
                theClass = 'false';
            elseif theName == 1
                theClass = 'true';
            else
                theClass = 'mixed';
            end
        end
        
        % shorter function names
        function theClass = valTrue(); theClass = seudo.getClassValue('true'); end
        function theClass = valFalse(); theClass = seudo.getClassValue('false'); end
        function theClass = valMix(); theClass = seudo.getClassValue('mixed'); end
        function theClass = valUnc(); theClass = seudo.getClassValue('unclassified'); end
        
        % get classification value
        function theValue = getClassValue(theClass)
            switch theClass
                case 'unclassified'
                    theValue = nan;
                case 'false'
                    theValue = -1;
                case 'true'
                    theValue = 1;
                case 'mixed'
                    theValue = 0;
                otherwise
                    error('classification type ''%s'' not recognized',theClass)
            end
        end
        
        
        % color palette to match paper
        function col = pickColor(whichColor)
            switch whichColor
                case 'true', col = [ 0,8,228];
                case 'false', col = [255,4,20];
                case 'mixed', col = [80 200 80];
                %case 'LSQ', col = [248,202,30]; % consensus
                %case 'LSQ', col = [95,52,0]; % original
                case 'LSQ', col = [248,156,0]; % consensus darkened
                case 'SEcell', col = [0,161,0];
                case 'SEblobs', col = [208,67,189];
                case 'artifact', col = [129 81 0];
                case 'unclassified', col = [128 128 128];
                otherwise
                    error('color ''%s'' not recognized',whichColor)
            end
            col = col/255;
        end
        
        
        
        function  [COMs,outerBounds] = computeRoiCOMs(rois)
            % compute COM for each ROI
            %
            % COMs = computeRoiCOMs(rois)
            %
            % rois - (Y x X x R) or (Y x X x 1 x R) matrix of ROIs
            % COMs - R x 2 matrix, each row = [comX comY]
            
            rois = squeeze(rois);
            nY = size(rois,1);
            nX = size(rois,2);
            
            [xx,yy] = meshgrid(1:nX,1:nY);
            
            COMs = nan(size(rois,3),2);
            outerBounds = nan(size(rois,3),4);
            
            for rr=1:size(rois,3)
                
                roi = rois(:,:,rr);
                
                % don't allow negative values to muck it up
                roi = abs(roi);
                
                xSum = sum(xx.*roi);
                ySum = sum(yy.*roi,2);
                
                rs = sum(roi(:));
                COMs(rr,:) = [sum(xSum) sum(ySum)]/rs;
                
                
                if nargout > 1
                    if any(roi(:))
                        outerBounds(rr,:) = [find(ySum,1,'first') find(ySum,1,'last') find(xSum,1,'first') find(xSum,1,'last')];
                    else
                        % if all zeros, set bounds to be just one pixel
                        outerBounds(rr,:) = [1 1 1 1];
                    end
                end
            end
            
        end
        
        
        
        function [sigma_est, varargout] = fit_blob_std(im_prof, dF, varargin)
            % [sigma_est, varargout] = fit_blob_std(im_prof, dF)
            %
            % Estimate the variance of the composite blob's standard deviation.
            % Additional options: 'dc' - include a DC componant, 'noise' - include a
            % constant componant (representative of Gaussian noise). Recommended to use
            % 'dc' only.
            %
            % 2018 - Adam Charles
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Input parsing
            
            p = inputParser;
            p.addParameter('dc'   , true);
            p.addParameter('noise', false);
            p.addParameter('n_gauss', 2);
            parse(p,varargin{:});
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Get DFTs
            
            if ~isempty(im_prof)
                im1 = abs(fftshift(fft2(double(im_prof))));                            % Get DFT of the profile
            end
            im2 = mean(abs(fftshift(fftshift(fft2(double(dF)),1),2)),3);               % Get average DFT of the movie frames
            Ng  = p.Results.n_gauss;
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Find parameters
            
            opts = optimoptions('fmincon','display','off');
            
            if (~isempty(im_prof))&&p.Results.dc&&p.Results.noise                      % Profile YES, DC YES, Noise YES
                recon_fun = @(z) norm(im2 - z(1)*im1 - seudo.gauss_fun(size(im2), reshape(z(2:(1+2*Ng)),Ng,2), z(2*Ng+2)) - z(2*Ng+3));
                z_est     = fmincon(recon_fun, ones(2*Ng+3,1), [], [], [], [], zeros(2*Ng+3,1), Inf*ones(2*Ng+3,1),[],opts);
            
            elseif (~isempty(im_prof))&&p.Results.dc&&(~p.Results.noise)               % Profile YES, DC YES, Noise NO
                recon_fun = @(z) norm(im2 - z(1)*im1 - seudo.gauss_fun(size(im2), reshape(z(2:(1+2*Ng)),Ng,2), z(2*Ng+2)));
                z_est     = fmincon(recon_fun, ones(2*Ng+2,1), [], [], [], [], zeros(2*Ng+2,1), Inf*ones(2*Ng+2,1),[],opts);
            
            elseif (~isempty(im_prof))&&(~p.Results.dc)&&p.Results.noise               % Profile YES, DC NO, Noise YES
                recon_fun = @(z) norm(im2 - z(1)*im1 - seudo.gauss_fun(size(im2), reshape(z(2:(1+2*Ng)),Ng,2), 0) - z(2*Ng+2));
                z_est     = fmincon(recon_fun, ones(2*Ng+2,1), [], [], [], [], zeros(2*Ng+2,1), Inf*ones(2*Ng+2,1),[],opts);
            
            elseif (~isempty(im_prof))&&(~p.Results.dc)&&(~p.Results.noise)            % Profile YES, DC NO, Noise NO
                recon_fun = @(z) norm(im2 - z(1)*im1 - seudo.gauss_fun(size(im2), reshape(z(2:(1+2*Ng)),Ng,2), 0));
                z_est     = fmincon(recon_fun, ones(2*Ng+1,1), [], [], [], [], zeros(2*Ng+1,1), Inf*ones(2*Ng+1,1),[],opts);
            
            elseif isempty(im_prof)&&p.Results.dc&&(~p.Results.noise)                  % Profile NO, DC YES, Noise NO
                recon_fun = @(z) norm(im2 - seudo.gauss_fun(size(im2), reshape(z(1:(2*Ng)),Ng,2), z(2*Ng+1)));
                z_est     = fmincon(recon_fun, ones(2*Ng+1,1), [], [], [], [], zeros(2*Ng+1,1), Inf*ones(2*Ng+1,1),[],opts);
            
            elseif isempty(im_prof)&&(~p.Results.dc)&&p.Results.noise                  % Profile NO, DC NO, Noise YES
                recon_fun = @(z) norm(im2 - seudo.gauss_fun(size(im2),reshape(z(1:(2*Ng)),Ng,2), 0) - z(2*Ng+1));
                z_est     = fmincon(recon_fun, ones(2*Ng+1,1), [], [], [], [], zeros(2*Ng+1,1), Inf*ones(2*Ng+1,1),[],opts);
            
            elseif isempty(im_prof)&&p.Results.dc&&p.Results.noise                     % Profile NO, DC YES, Noise YES
                recon_fun = @(z) norm(im2 - seudo.gauss_fun(size(im2), reshape(z(1:(2*Ng)),Ng,2), z(2*Ng+1)) - z(2*Ng+2));
                z_est     = fmincon(recon_fun, ones(2*Ng+2,1), [], [], [], [], zeros(2*Ng+2,1), Inf*ones(2*Ng+2,1),[],opts);
            
            elseif isempty(im_prof)&&(~p.Results.dc)&&(~p.Results.noise)               % Profile NO, DC NO, Noise NO
                recon_fun = @(z) norm(im2 - seudo.gauss_fun(size(im2), reshape(z(1:(2*Ng)),Ng,2), 0));
                z_est     = fmincon(recon_fun, ones(2*Ng,1), [], [], [], [], zeros(2*Ng,1), Inf*ones(2*Ng,1),[],opts);
            end
            
            if isempty(im_prof)
                z_est = [NaN; z_est(:)];
            else
                z_est = z_est(:);
            end
            
            sigma_est = z_est((2+Ng):(1+2*Ng));
            sigma_est = sigma_est(find(abs(sigma_est-1.5)==min(abs(sigma_est-1.5)),1));
            sigma_est  = 1./sigma_est ;
            
            % sigma_est = 1./z_est((2+Ng):(1+2*Ng));
            % sigma_est = sigma_est(find(abs(sigma_est-5)==min(abs(sigma_est-5)),1));
            
            if nargout > 1
                varargout{1} = z_est(:);
            end
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        end
        
        
        
        function gauss_img = gauss_fun(sz, g_params, varargin)
            
            % gauss_img = gauss_fun(sz, g_mag, sigma, z_delta)
            %
            % Make an image that is a frequency-domain Gaussian centered at 0 with
            % standard devaition sigma and of size sz.
            %
            % 2018 - Adam Charles
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Initialize
            
            if nargin > 2
                z_delta = varargin{1};
            else
                z_delta = 0;
            end
            
            x_vals = fftshift(reshape(0:(sz(1)-1),[],1)/sz(1));                                 % Get x-freq values
            x_vals = min(x_vals, abs(1-x_vals));                                       % Make sure the domain is circular
            y_vals = fftshift(reshape(0:(sz(2)-1),[],1)/sz(2));                                 % Get y-freq values
            y_vals = min(y_vals, abs(1-y_vals));                                       % Make sure the domain is circular
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Make Gaussian image
            
            gauss_img = 0;
            for kk = 1:size(g_params,1)
                gauss_img = gauss_img + g_params(kk,1)*exp(-bsxfun(@plus, ...
                    x_vals.^2, (y_vals.').^2)/(2*g_params(kk,2)^2)); % Make the Gaussian image
            end
            gauss_img = gauss_img + z_delta*(x_vals==0)*(y_vals.'==0);                 % Add an optional DC value
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        end
        
        
        
        
        
        function rstd = robustSTD(data)
            % robustSTD   compute robust standard deviation
            %
            % usage: rstd = robustSTD(data)
            %
            % arguments:     data - vector of numbers
            %                       or array - operates along 1st dim
            %
            % outputs:       rstd - robust standard deviation
            %
            %
            % translated from lisp (statistics.lisp) to matlab by JLG, 2007-07-17
            %
            % ;; Function ROBUST-STANDARD-DEVIATION
            % ;; ESF 2003-08-13
            % ;; made more efficient by EJC 2003-08-14
            % ;; calculates a robust standard deviation
            % ;; see PJ Huber (1981), Robust Statistics, Wiley, call number QA 276.H785
            % ;; hardcoded constant is inverse cumulative normal evaluated at 0.75
            % ;; this computation performs well if
            % ;; (1) data near the mean approximately follow a normal distribution,
            % ;; (2) the outliers are outside the 25%-75% percentiles.
            %
            % 2008-10 greschner loop over 2nd dim
            % 2008-10 gauthier  remove loop for increased speed
            %
            
            % handle empty case
            if isempty(data)
                rstd = [];
                return
            end
            
            % if one dimensional, make sure it is a column
            if find(size(data)==1)==1
                data=data';
            end
            
            % identify median of each column, and subtract it from each entry in the column
            data = data - repmat(nanmedian(data),size(data,1),1);
            
            % rest of computation
            rstd = nanmedian(abs(data)) ./ 0.6741891400433162;
        end
        
        
        
        function transientFrames = identifyTransients(timeCourses,varargin)
            % seudo.identifyTransients(timeCourses,...)
            %
            % identify transients in a given set of time courses
            %   (this function is called automatically when needed)
            %
            %
            %
            % PARAMETERS
            %
            %   threshFcn - function applied to each cell time course to identify time points
            %                   containing a significant increase in fluorescence. in the binarized
            %                   time course, each connected component is considered a candidate transient.
            %   blurRadius - candidate time courses are extended by length blurRadius in both directions
            %                   before their onset and offset is computed. this serves to join components
            %                   that are separated by small gaps.
            %   minDuration - minimum duration (in frames) for a candidate transient to be included
            %
            %
            
            
            % parse inputs
            p = inputParser;
            p.addParameter('threshFcn'         , @(x)max(seudo.robustSTD(x)*5,prctile(x,95)));
            p.addParameter('blurRadius'        , 2); 
            p.addParameter('minDuration'       , 6);
            parse(p,varargin{:});
            params = p.Results;
            clear p

            
            
            % initialize output
            transientFrames = false(size(timeCourses));
            
            % loop over sources
            for cc=1:size(timeCourses,2)
                
                tc = timeCourses(:,cc);
                
                % compute frames with a significant transient
                
                % threshold
                th = params.threshFcn(tc);
                
                % get points over threshold
                tcTh = tc > th;
                
                % Take points > threshold and blur by several time points
                tcTh = conv(double(tcTh),ones(1,params.blurRadius*2+1),'same') > 0;
                
                
                
                % remove transients that are too short
                
                % segment thresholded time course
                tcSeg = bwlabel(tcTh);
                
                % identify duration of each transient
                transDur = hist(tcSeg,0:max(tcSeg));
                transDur = transDur(2:end);
                
                % delete brief transients
                tcSeg(ismember(tcSeg,find(transDur < params.minDuration))) = 0;
                
                
                
                % binarize
                transientFrames(:,cc) = tcSeg > 0;
                
            end
            
        end
        
        
        
        
        function evalFcn = makeTimeCourseEvalFunction(varargin)
            % create function to measure how much of an original transient is preserved by SEUDO
            %
            % USAGE: evalFcn = makeTimeCourseEvalFunction(varargin)
            %
            % EXAMPLE: 
            %
            %   evalFcn = makeTimeCourseEvalFunction('method','area);
            %   residualFraction = evalFcn(tcOrig,tcNew);
            %
            % PARAMETERS:
            %
            %   method - how to measure transient preservation
            %           'area' - sum of new transient divided by sum of original transient
            %           'tall span' - fraction of time points where new transient is at least X% as tall as original transient
            %
            %   threshSigTrans - threshold for being considered a significant part of the transient (dF/F units)
            %               only applies to 'tall span'
            %
            %   threshTall - how far (fraction) the new transient can fall and still be considered preserved
            %               only applies to 'tall span'
            %   
            
            
            p = inputParser;
            p.addParameter('method'         , 'area');
            p.addParameter('threshSigTrans' , 0.1); 
            p.addParameter('threshTall'     , 0.2); 
            p.addParameter('minDuration'    , 0.5); % fraction of original duration time course can be shortened to still count as long enough
            parse(p,varargin{:});
            
            params = p.Results;
            
            
            switch params.method
                case 'area' % fraction kept
                    
                    evalFcn = @(tcOrig,tcNew) sum(tcNew(tcNew>0))/sum(tcOrig(tcOrig>0));
                    
                    
                case 'tall span' % fraction of points above X% of original
                    
                    thresh = params.threshSigTrans;
                    fallFraction = params.threshTall;
                    
                    evalFcn = @(tcOrig,tcNew) sum(tcNew(tcOrig>thresh) > tcOrig(tcOrig>thresh)*fallFraction) / sum(tcOrig>thresh);
                    
                    
                case 'tall span threshold' % duration greater than
                    
                    thresh = params.threshSigTrans;
                    minDuration = params.minDuration;
                    fallFraction = params.threshTall;
                    
                    evalFcn = @(tcOrig,tcNew) sum(tcNew(tcOrig>thresh) > tcOrig(tcOrig>thresh)*fallFraction) / sum(tcOrig>thresh) >= minDuration;
                    
                otherwise
                    error('method %s not recognized',params.method)
            end

            

        end
        
        
        
        function cmap = colormapGreenMagenta(nShades,pwr)
            % return colormap with a green to black to magenta gradient
            % cmap = colormapGreenMagenta(nShades,pwr)
            %
            % arguments (optional, provide [] to skip)
            %
            % nShades - number of colors in each half.  size(cmap,1) = nShades*2 + 1
            % pwr - used to change gamma
            %
            
            
            % use default values is none provided
            if ~exist('nShades','var') || isempty(nShades)
                nShades = 50;
            end
            
            if ~exist('pwr','var') || isempty(pwr)
                pwr = 1;
            end
            
            
            % generate gradient of values
            grad = linspace(0,1,nShades+1)' .^ pwr;
            grad = grad(1:end-1);
            gradF = flipud(grad);
            
            % assemble colormap
            cmap = [gradF zeros(nShades,1) gradF; ...       magenta gradient
                zeros(1,3); ...                             pure black
                zeros(nShades,1) grad zeros(nShades,1)];  % blue gradient

        end
        
        
        function tMat = makeThumbnailMatrix(M,varargin)
            % reshape frames of input 3D matrix into 2D grid with padding
            %
            %
            % EXAMPLE:
            %
            % M = cat(3,A,B,C,D);
            % makeThumbnailMatrix(M,'padVal',0)
            %   -->
            %    00000
            %    0A0B0
            %    00000
            %    0C0D0
            %    00000
            %
            
            
            %    +-+-+
            %    |A|B|
            %    +-+-+
            %    |C|D|
            %    +-+-+
            %
            
            
            p = inputParser;
            p.addParameter('xPad',1); %
            p.addParameter('yPad',1); %
            p.addParameter('padVal',nan); %
            p.addParameter('nX',[]); %
            p.addParameter('nY',[]); %
            parse(p,varargin{:});
            
            
            
            xPad = p.Results.xPad;
            yPad = p.Results.yPad;
            padVal = p.Results.padVal;
            
            
            n = size(M,3);
            
            % set size
            if ~isempty(p.Results.nX)
                nX = p.Results.nX;
                nY = ceil(n/nX);
            elseif ~isempty(p.Results.nY)
                nY = p.Results.nY;
                nX = ceil(n/nY);
            else
                nX = ceil(sqrt(n));
                nY = ceil(n/nX);
            end
            
            
            
            % append extra frames
            nExtra = nX*nY - n;
            M = cat(3,M,repmat(padVal*ones(size(M(:,:,1))),[1 1 nExtra]));
            
            % add padding
            M = padarray(M,[yPad xPad],padVal,'post');
            
            % make into one long row
            M = reshape(M,size(M,1),[]);
            
            % make different rows (of the final matrix) in the 3rd dimension
            M = reshape(M,size(M,1),[],nY);
            
            % make into square
            tMat = reshape(permute(M,[1 3 2]),nY*size(M,1),[]);
            
            % add padding on top and left
            tMat = padarray(tMat,[yPad xPad],padVal,'pre');
        end

        
        function tIn = temp_updateClassification(tIn)
            % update classification from old scheme (pre Jan 2019)
            
            % loop over versions of these time courses
            for ss = 1:length(tIn)
                
                % loop over cells
                for cc = 1:length(tIn(ss).transientInfo)
                    
                    oldClass = tIn(ss).transientInfo(cc).classification;
                    newClass = oldClass;
                    
                    % loop over transients
                    for tt = 1:length(oldClass)
                        
                        % identify class
                        thisClass = oldClass(tt);
                        if thisClass == 1
                            % true
                            newVal = seudo.valTrue;
                        elseif thisClass == -1
                            % false
                            newVal = seudo.valFalse;
                        elseif isnan(thisClass)
                            % unclassified
                            newVal = seudo.valUnc;
                        else
                            % mixed
                            newVal = seudo.valMix;
                        end
                        % assigne
                        newClass(tt) = newVal;
                    end
                    
                    % assign to original
                    tIn(ss).transientInfo(cc).classification = newClass;
                end
            end
            
            
        end

        
    end
    
    
    
end

